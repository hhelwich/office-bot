let __hasProp = {}.hasOwnProperty;

// Binds a function to a context
// :: (->, {}) -> ->
let bind = (fn, context) => {
  return function() {
    return fn.apply(context, arguments);
  };
};

// Aliases
let _console = console;
let log = bind(_console.log, _console);
let error = bind(_console.error, _console);

let _ref = Array.prototype;
let slice = _ref.slice;
let push = _ref.push;

if (typeof TEST !== "undefined" && TEST !== null && TEST) {
  console.log("test mode on");
}

if (typeof DEBUG !== "undefined" && DEBUG !== null && DEBUG) {
  console.log("debug mode on");
}

// Returns true if the given value is of type boolean and is true.
// * -> boolean
let isTrue = (value) => {
  return value === true;
};

// Function that does nothing
// :: ->
let nop = () => {};

// A function to be called on the start of each queue message generated by this type.
// Can e.g. be used for debugging.
// :: ->
let onNext = nop;

// Add the given function to the message queue.
// :: (->) ->
let async = (f) => {
  setTimeout(() => {
    onNext();
    return f();
  }, 0);
};

// Returns `true` if the given value is a function.
// :: * -> boolean
let isFunc = (f) => {
  return typeof f === "function";
};

// Returns a function. A function input is returned directly, Other values will result in a function that does nothing.
// :: * -> ->
let toFunc = (f) => {
  if (isFunc(f)) {
    return f;
  } else {
    return nop;
  }
};

// Convert an argument object to an array.
// :: Arguments -> [*]
let toArray = (args) => {
  return slice.call(args, 0);
};

// Shallow copy an array.
// :: [*] -> [*]
let copyArray = (array) => {
  return array.slice();
};

// Appends content of second array to the end of the first array. Returns the changed first array.
// :: ([*], [*]) -> [*]
let appendArray = (a1, a2) => {
  push.apply(a1, a2);
  return a1;
};

// Returns the number of own key/value pairs in the given object.
// :: {} -> number
let objLength = (obj) => {
  return (Object.keys(obj)).length;
};

// Returns true if the given object has no own key/value pair.
// :: {} -> boolean
let isEmpty = (obj) => {
  return objLength(obj) === 0;
};

// Function composition
let compose = function() {
  let fns;
  fns = toArray(arguments);
  return function() {
    let fn, result, _i;
    result = (fns.pop()).apply(null, arguments);
    for (_i = fns.length - 1; _i >= 0; _i += -1) {
      fn = fns[_i];
      result = fn(result);
    }
    return result;
  };
};

// Returns a sequence generator function.
// :: -> -> number
let createSequence = () => {
  let counter = 0;
  return () => {
    return counter++;
  };
};

// Observable unique id generator function.
// :: -> number
let observableId = createSequence();

// Internal Observable constructor function
// :: (->) -> Obs<T>
let Obs = function() {
  this._id = observableId();
};

// Returns true if the given value is an observable
// :: * -> boolean
let isObservable = (obs) => {
  return obs instanceof Obs;
};

// Call the given function if the last `n` elements of the `args` array are instances of `Obs`, otherwise return a
// function which waits for more arguments to be appended on the current arguments.
// (->, [*], number) -> ->
let waitForObs = (fn, args, n) => {
  return function() {
    let args2, i, len, _i, _j;
    args2 = appendArray(copyArray(args), arguments);
    len = args2.length;
    for (i = _i = n; _i >= 1; i = _i += -1) {
      if (!isObservable(args2[len - i])) {
        return waitForObs(fn, args2, n);
      }
    }
    // The last n arguments are Observables => call function but move Observables from tail to head
    for (i = _j = 0; _j < n; i = _j += 1) {
      args2.unshift(args2.pop());
    }
    return fn.apply(null, args2);
  };
};

// Return a function which calls the given function if its last `n` arguments are instances of Obs, otherwise return a
// function which waits for more arguments to be appended on the given arguments.
let curryObs = (n, fn) => {
  return waitForObs(fn, [], n);
};

// Call the given function if enough arguments are given, otherwise return function which waits for more arguments.
// :: (->, [*]) -> *
let waitForArgs = (fn, args) => {
  if (args.length >= fn.length) {
    return fn.apply(null, args);
  } else {
    return function() {
      return waitForArgs(fn, args.concat(toArray(arguments)));
    };
  }
};

// Function currying
let curry = (fn) => {
  return function() {
    return waitForArgs(fn, toArray(arguments));
  };
};

// Unique id generator function for listeners. It would be possible to have a listener id generator per observable but
// then it would be needed to store the generator in the observable itself (for GC) so we make a global generator here
// instead.
// :: -> number
let listenerId = createSequence();

// All active listeners to all active observables are stored here.
// :: string -> string -> { onValue: ->, onError: ->, onEnd: -> }
let obsListeners = {};

// Add a new listener function for an existing observable.
// Returns a function to deregister the listener.
// :: (Observable, (T ->), (* ->), (->)) ->
let addListener = (obs, onValue, onError, onEnd) => {
  let deregister, lid, listeners;
  // Get listeners of observable
  listeners = obsListeners[obs._id];
  if (listeners == null) {
    obsListeners[obs._id] = listeners = {};
    if (obs._reg != null) {
      deregister = obs._reg.call(obs);
    }
  }
  // Add new listener
  lid = listenerId();
  listeners[lid] = {
    onValue: toFunc(onValue),
    onError: toFunc(onError),
    onEnd: toFunc(onEnd)
  };
  // Return deregister function
  return () => {
    delete listeners[lid];
    if (isEmpty(listeners)) {
      delete obsListeners[obs._id];
      if (deregister != null) {
        deregister.call(obs);
        deregister = null;
      }
    }
  };
};

let removeListener = (obs, lid) => {};

// Iterate key/value pairs of an object
// :: ((string -> *), ((string, *) ->)) ->
let iterate = (obj, callback) => {
  let key, value;
  for (key in obj) {
    if (!__hasProp.call(obj, key)) {
      continue;
    }
    value = obj[key];
    callback(key, value);
  }
};

// Emit the given value on the observable with the given id.
// :: string -> * ->
let trigger = curry((oid, value) => {
  if (value !== void 0) {
    iterate(obsListeners[oid], (_, listener) => {
      listener.onValue(value);
    });
  }
});

// Emit the given error object on the observable with the given id.
// :: string -> * ->
let triggerError = curry((oid, error) => {
  iterate(obsListeners[oid], (_, listener) => {
    listener.onError(error);
  });
});

// End the observable with the given id.
// :: string -> ->
let triggerEnd = (oid) => {
  return () => {
    iterate(obsListeners[oid], (_, listener) => {
      listener.onEnd();
    });
  };
};

// Calls the given function with a push function to emit values on the given observable.
// (Observable, (->)) -> Observable
let pushValues = (obs, create) => {
  let checkEnd, id, msgCount, next, register;
  register = null;
  id = obs._id;
  msgCount = 0; // How much messages are in the queue for this observable
  checkEnd = () => {
    if (register == null && msgCount === 0) { // No more messages in queue => end observable
      async(triggerEnd(id));
    }
  };
  next = (fn) => {
    async(() => {
      let e;
      try {
        fn.call(obs);
      } catch (_error) {
        e = _error;
        triggerError(id)(e);
      }
      msgCount -= 1;
      checkEnd();
    });
    msgCount += 1;
  };
  register = create.call(obs, trigger(id), next);
  checkEnd();
  if (register != null) {
    obs._reg = register;
  }
  return obs;
};

let globals = {
  // ((A -> B), Observable<A>) -> Observable<B>
  map: curryObs(1, (obs, fn, seed) => {
    let deregister, id, ob0, _trigger, _triggerError;
    ob0 = new Obs();
    id = ob0._id;
    _trigger = trigger(id);
    _triggerError = triggerError(id);
    deregister = addListener(obs, (value) => {
      async(() => {
        let e;
        try {
          _trigger(fn(value));
        } catch (_error) {
          e = _error;
          _triggerError(e);
        }
      });
    }, (e) => {
      async(() => {
        _triggerError(e);
      });
    }, () => {
      deregister();
      async(triggerEnd(id));
    });
    return ob0;
  }),
  take: (count, obs) => {
    let deregister, i, id, ob, _trigger, _triggerError;
    ob = new Obs();
    id = ob._id;
    _trigger = trigger(id);
    _triggerError = triggerError(id);
    i = 0; // Number of taken values
    deregister = addListener(obs, (value) => {
      if (i < count) {
        async(() => {
          _trigger(value);
        });
      }
      i += 1;
      if (i >= count) {
        deregister();
        async(triggerEnd(id));
      }
    }, (e) => {
      async(() => {
        _triggerError(e);
      });
    }, () => {
      deregister();
      async(triggerEnd(id));
    });
    return ob;
  },
  filter: curryObs(1, (obs, predicate) => {
    let deregister, elements, id, len, ob0, _trigger, _triggerError;
    ob0 = new Obs();
    id = ob0._id;
    _trigger = trigger(id);
    _triggerError = triggerError(id);
    len = predicate.length;
    elements = [];
    deregister = addListener(obs, (value) => {
      let e;
      try {
        if (isTrue(predicate(value))) {
          async(() => {
            _trigger(value);
          });
        }
      } catch (_error) {
        e = _error;
        async(() => {
          _triggerError(e);
        });
      }
    }, (e) => {
      async(() => {
        _triggerError(e);
      });
    }, () => {
      deregister();
      async(triggerEnd(id));
    });
    return ob0;
  })
};

// Prototype for all Observables.
let obsProto = Obs.prototype = {
  log: function(prefix) {
    addListener(this, (value) => {
      log(prefix, value);
    }, (e) => {
      error(prefix, e);
    }, () => {
      log(prefix, "<end>");
    });
  },
  forEach: function(onValue, onError, onEnd) {
    return addListener(this, onValue, onError, onEnd);
  },
  map: function(fn) {
    return globals.map(fn, this);
  },
  filter: function(predicate) {
    return globals.filter(predicate, this);
  },
  take: function(count) {
    return globals.take(count, this);
  }
};

// Constructor function for a new Observable. It should be used without `new`.
let Observable = (creator) => {
  return pushValues(new Obs(), creator);
};

Observable.prototype = obsProto; // For instanceof

// Will be called at the start of each queue message created by this type
// :: (->) ->
Observable.onNext = (callback) => {
  onNext = toFunc(callback);
};

// Returns an observable which emits all elements of the given array.
// :: [*] -> Observable
Observable.fromArray = (array) => {
  array = array.slice(0); // Shallow copy array
  return Observable((push, next) => {
    let pushIfAvailable, pushNext;
    pushIfAvailable = () => {
      if (array.length > 0) {
        next(pushNext);
      }
    };
    pushNext = () => {
      push(array.shift());
      pushIfAvailable();
    };
    pushIfAvailable();
  });
};

Observable.once = (value) => {
  return Observable.fromArray([value]);
};

// Copy all global functions to the exported object.
iterate(globals, (name, fn) => {
  Observable[name] = fn;
});

this.speck = {
  Observable: Observable
};

// Export internals for white box tests
if (typeof TEST !== "undefined" && TEST !== null && TEST) {
  this.speck._private = {
    toArray: toArray,
    copyArray: copyArray,
    appendArray: appendArray,
    compose: compose,
    curry: curry,
    curryObs: curryObs,
    isFunc: isFunc,
    isObservable: isObservable
  };
}

export default Observable;
